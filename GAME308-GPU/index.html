<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>GAME 308</title>
    <link rel="stylesheet" type="text/css" href="../HumberStyle.css" media="all" />
</head>
<body>
    <div id="header"> <b>GAME 308 GPU </b><br />Vulkan</div>
    <ul class="nav">
        <li class="nav"><a class="nav" href="../index.html"> Home </a><br /></li>
        <li class="nav"><a class="nav" href="../MySchedule"> My schedule </a><br /></li>
        <li class="nav"><a class="nav" href="../AboutMe"> About me </a><br /></li>
        <li class="nav"><a class="nav" href="../ETC"> /etc </a><br /></li>
    </ul>

    <div id="rightsidebar">
        <h3> Helpful tools</h3>
        <a class="nav" href="../Rubrics/programmingRubric.html">General Programming Rubric</a><br />
        <a class="nav" href="https://vulkan-tutorial.com/Introduction">Vulkan Tutorial</a><br />
        <a class="nav" href="https://drive.google.com/file/d/1jL9kQWZ4oxqJvgEwLSTd3wbzSTaT8NF8/view?usp=sharing">GameDev</a><br />
        <a class="nav" href="../CodeDepot/ComponentFramework24.0.2 Vulkan.zip">ComponentFramework24.0.2 Vulkan.zip</a><br />
        <a class="nav" href="compileShaders.bat">compileShaders.bat</a><br />
        <a class="nav" href="simplePhong.vert"> simplePhong.vert</a><br />
        <a class="nav" href="simplePhong.frag"> simplePhong.frag</a><br />
        <a class="nav" href="phong.vert"> phong.vert</a><br />
        <a class="nav" href="phong.frag"> phong.frag</a><br />
        <!--
        Videos from the online class from last semester<br />
        <a class="nav" href="https://youtu.be/aODHSCZvpjw">Week 1</a><br />
        <a class="nav" href="https://youtu.be/VrOVnP3grwk">Week 2</a><br />
        <a class="nav" href="https://youtu.be/C_uF_OJRPCQ">Week 3</a><br />
        <a class="nav" href="https://youtu.be/SJyvrveztGM">Week 4</a><br />

        <a class="nav" href="https://youtu.be/d9jQ9ZMFA-E">Week 5</a><br />
        <a class="nav" href="https://youtu.be/QvpvUjV4mRs">Week 6</a><br />
        <a class="nav" href="https://youtu.be/dqhG2KHzomM">Week 7</a><br />
        <a class="nav" href="https://youtu.be/QcgHwMOxfYk">Week 8</a><br />
        <a class="nav" href="https://youtu.be/DkGYoj7l8lI">Week 9</a><br />

        <a class="nav" href="https://youtu.be/sHmGOoBrp9g">Week 10.1 I went over the content again, audio failed.</a><br />
        <a class="nav" href="https://youtu.be/mYg2aXoj4jg">Week 11 </a><br />
        <a class="nav" href="https://youtu.be/0QSHzbnXHAg">Week 12 </a><br />
            -->
    </div>

    <H1> Welcome to Graphics 308 - GPU programming with Vulkan </H1>
    <div>

        <H2>Assignment 0:(not graded)<br /> </H2>
        <p>
            You really need to download the latest copy of GameDev (I had to move it to a GoogleDrive - it is too big).<br />
            Be sure you have installed Vulkan on your machine..<br />
            Download ComponentFramework24.0.2 Vulkan and get it to run.<br />
            <a class="nav" href="../CodeDepot/ComponentFramework24.0.2 Vulkan.zip">ComponentFramework24.0.2 Vulkan.zip</a><br />
            <br /><br />
        </p>
        <H2>Assignment 1:(15/20)<br /> </H2>
        <p>
            In this project I want you to use a push constant to shoot over Mario's model matrix to the pipeline (shader).<br />
            Push are a slightly different way of passing data the shader. In fact, it is even faster than using uniform buffers. 
            But, they do have a drawback, they are restricted to a maximum of 128 bytes of memory. Can you do a projection, view,
            and model maxtrix in 128 bytes? Quick answer, no. So the camera will remain a UBO.<br />
            Since this is the first assignment, I'll walk you through it:<br/>
            1) Create a new struct something like this<br/>
            <textarea class="code" cols=127 rows=5 spellcheck="false">
                struct ModelMatrixPushConst {
                    Matrix4 modelMatrix;
                    Matrix4 normalMatrix;
                };
             </textarea><br/>

            2) Create a member variable in the VulkanRender of type ModelMatrixPushConst <br/>

            3) Create a new structure in the CreateGraphicsPipeline() <br/>
            <textarea class="code" cols=127 rows=5 spellcheck="false">
                VkPushConstantRange pushConstant{};
                pushConstant.offset = 0;
                pushConstant.size = sizeof(ModelMatrixPushConst);
                pushConstant.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
             </textarea><br/>

            4) Add the following lines to the VkPipelineLayoutCreateInfo structure:<br/>
            <textarea class="code" cols=127 rows=3 spellcheck="false">
                pipelineLayoutInfo.pPushConstantRanges = &pushConstant;
                pipelineLayoutInfo.pushConstantRangeCount = 1;
            </textarea><br/>

            5) Break createCommandBuffer() in two, call the second on recordCommandBuffer().
            Add recordCommandBuffer() just below createCommandBuffer();
            At the top of the recordCommandBuffer() add vkDeviceWaitIdle(device); 
            The correct way is to use semaphores - sorry, we don't have time. <br/>
            The createCommandBuffers should now look like this:<br/>
             <textarea class="code" cols=127 rows=14 spellcheck="false">
                void VulkanRenderer::createCommandBuffers() {
                    commandBuffers.resize(swapChainFramebuffers.size());

                    VkCommandBufferAllocateInfo allocInfo{};
                    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
                    allocInfo.commandPool = commandPool;
                    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
                    allocInfo.commandBufferCount = (uint32_t)commandBuffers.size();

                    if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) {
                        throw std::runtime_error("failed to allocate command buffers!");
                    }
                }
             </textarea><br/>
            The rest of the code should be in recordCommandBuffer()<br/>


            5.1) Since you cannot take a hint, add the following to the recordCommandBuffer(), just above vkCmdDrawIndexed().
             <textarea class="code" cols=127 rows=2 spellcheck="false">
             vkCmdPushConstants(commandBuffers[i], pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0,
                sizeof(ModelMatrixPushConst),&"whatEverThePushIsCalled");
            </textarea><br/>

            5.2) In order to put data into "whatEverThePushIsCalled , you'll need to write something like:<br/>
            void SetModelMatrix(const Matrix4& modelMatrix); <br/>


            6) Now, on to the shaders. Add the following code to the vertex shader module:
             <textarea class="code" cols=127 rows=5 spellcheck="false">
                layout(push_constant) uniform Push {
	                mat4 modelMatrix;
	                mat4 normalMatrix;
                } push;
              </textarea><br/>
            Don't forget to remove the model matrix from the Camera UBO and to recompile the shaders. 

            <br /><br />
            Extra: It is stupid to calculate the normal matrix on the fly in the vertex shader with the transpose(inverse(of the modelmatrix). 
            What, calculate the normal matrix for every vertex in the model?  That's madness. Find a better way. I'll hint in class.  <br /><br />

            Extra: If you know too much, the normal matrix is just a rotation therefore really just a 3x3 matrix. However, alighnment 
            rules need to be enforced. See std430 or std140 for detail and see my header file UBO_Padding.h.  It's just for you to show off. <br /><br />
        </p>
    <H2>Assignment 2:(15/20)<br /> </H2>
        <p>
            Create a two light system. This will require you to modify the shaders and recompile the shaders. You will also need to modify
            the UBO to create a cameraUBO and a lighsUBO on both the CPU and GPU to carry the lighing data.<br />
            Of course, I will help, if you come to class<br />
            Extra: Create ambient, difffuse, and spectular colour for the new light system.<br />
            Extra: Create more that two lights.<br />
        </p>
    </div>
</body>
</html>

